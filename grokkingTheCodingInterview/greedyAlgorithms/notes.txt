- assume that choosing local optimum will lead to global optimum
- greedy choice property: best solution at each small step leads to best overall solution
- optimal substructure: optimal solution to entire problem contains optimal solutions to its subproblems
- characteristics of greedy algorithm
  - local optimization: best choice at the moment
  - irrevocability: once a choice is made, it can't be undone or revisited
    - dynamic programming: similar but decisions can be re-evaluated
- components of greedy algorithm
  - candidate set: set of choices available at each step
  - selection function: chooses most promising candidate to add to current solution
  - feasability function: checks if candidate can contribute to solution w/o violating problem constraints
  - objective function: evaluate value or quality of solution at each step
  - solution function: determines if complete solution has been reached
- simplified greedy algorithm process
  - start with empty solution set: no items in solution set at beginning
  - iterative item selection: each step, choose most suitable item based on current goal
  - add item to solution set: add selected item to solution
  - feasability check: does the updated solution set still meet problem's constraints
  - accept or reject the item
    - if feasible: keep in solution set
    - if not feasible: remove and permanently discard item
  - repeat until complete: continue process until full solution is formed or no feasible solution can be found
  - assess final solution: evaluate completed solutions against problem's objectives
- pros:
  - time and space efficiency
  - ease of implementation
  - optimal for certain problems
  - useful for approximations
- cons:
  - not always optimal
  - shortsighted approach

- standard greedy algorithms
  - kruskal's minimum spanning tree: build min spanning tree by adding shortest edge that doesn't form cycle
  - prim's minimum spanning tree: grows min spanning tree from starting vertex by adding nearest vertex
  - dijkstra's shortest path: shortest path from single source to all other vertices in weighted graph
  - huffman coding: data compression, builds binary tree with min weighted path lengths for given chars 
  - fractional knapsack problem: maximizes total value of items in knapsack without exceeding its capacity
  - activity selection problem: select max num activities that don't overlap in time
  - greedy best-first search: used in AI for pathfiding and graph traversal, prioritize paths that seem closest to goal